#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title:: *)
(*Coral-algae model from Cunning et al 2017*)


(* ::Subtitle:: *)
(*Numerics: ODE method, with 2 fluxes as state variables*)


(* ::Input:: *)
(*(*parameters*)*)
(*parvals={nNH->0.18`,nNS->0.13`,nNX->0.2`,j0HT->0.03`,j0ST->0.03`,\[Sigma]NH->0.9`,\[Sigma]CH->0.1`,\[Sigma]NS->0.9`,\[Sigma]CS->0.9`,jXm->0.13`,KX->1/1000000,jNm->0.035`,KN->1.5`*^-6,kCO2->10,jHGm->1,yCL->0.1`,yC->0.8`,astar->1.34`,kNPQ->112,kROS->80,jCPm->2.8`,jSGm->0.25`,b->5,X->0(*2/10000000*),\[CapitalNu]->1.5`*^-6,L->30,\[Lambda]->40,tmax->500};*)
(*fluxvars={jCP,jSG};*)
(*(*initial values*)*)
(*inivalues={jSG->0,jCP->jCPm,H->1,S->.3}/.parvals;*)
(*(*derived*)*)
(*(*SU*)*)
(*F[\[Rho]_][A_,B_]:=(A B (A+B) \[Rho])/(A^2 B+A B^2+A^2 \[Rho]+A B \[Rho]+B^2 \[Rho]);*)
(*rules={*)
(*jX->(jXm X)/(X+KX),*)
(*jN->(jNm \[CapitalNu])/(\[CapitalNu]+KN),*)
(*jHT->j0HT,*)
(*rNS->\[Sigma]NS nNS j0ST,*)
(*jHG->F[jHGm][yC (\[Rho]C S/H+jX),(jN+nNX jX+rNH)nNH^-1],*)
(*jeC->jX-jHG/yC+(S \[Rho]C)/H,*)
(*jCO2->jeC kCO2,*)
(*jL->A astar L,*)
(*rCH->(jHT+(jHG (1-yC))/yC) \[Sigma]CH,*)
(*jeL->jL-jCP/yCL,*)
(*jNPQ->1/(1/jeL+1/kNPQ),*)
(*jST->(1+b cROS1) j0ST,*)
(*rNH->\[Sigma]NH nNH jHT,*)
(*A->1.256307+1.385969 E^(-6.479055 S/H),*)
(*rCS->\[Sigma]CS(j0ST+(1-yC)jSG yC^-1),*)
(*cROS1->Max[0,jeL-jNPQ]/kROS,*)
(*\[Rho]C->jCP-jSG yC^-1,*)
(*\[Rho]N->jN+jX nNX+rNH-jHG nNH,*)
(*jSG->F[jSGm][jCP yC,(rNS+(H \[Rho]N)/S)/nNS],*)
(*jCP->F[jCPm][jL yCL,rCS+(H (jCO2+rCH))/S]/(1+cROS1)*)
(*};*)
(*(*names of the state variables*)*)
(*names={jHG->"\!\(\*SubscriptBox[\(j\), \(HG\)]\)",\[Rho]N->"\!\(\*SubscriptBox[\(\[Rho]\), \(N\)]\)",jeC->"\!\(\*SubscriptBox[\(j\), \(eC\)]\)",jCO2->"\!\(\*SubscriptBox[\(j\), SubscriptBox[\(CO\), \(2\)]]\)",jL->"\!\(\*SubscriptBox[\(j\), \(L\)]\)",rCH->"\!\(\*SubscriptBox[\(r\), \(CH\)]\)",rCS->"\!\(\*SubscriptBox[\(r\), \(CS\)]\)",jCP->"\!\(\*SubscriptBox[\(j\), \(CP\)]\)",jeL->"\!\(\*SubscriptBox[\(j\), \(eL\)]\)",jNPQ->"\!\(\*SubscriptBox[\(j\), \(NPQ\)]\)",cROS1->"\!\(\*SubscriptBox[\(c\), \(ROS\)]\)-1",jSG->"\!\(\*SubscriptBox[\(j\), \(SG\)]\)",\[Rho]C->"\!\(\*SubscriptBox[\(\[Rho]\), \(C\)]\)",jST->"\!\(\*SubscriptBox[\(j\), \(ST\)]\)",S->"S",H->"H"};*)
(**)
(*simulate[pars_,fluxvars_,inivalues_]:=Module[{rulesnofluxvars,tsolve,states},*)
(*rulesnofluxvars=Select[rules,Not[MemberQ[fluxvars,#[[1]]]]&];*)
(*(*list of states (fluxes) to track*)*)
(*(*format of elements in this list:*)*)
(*(*{ variable name, formula (aim for numerical implementation), initial guess (for numerical implementation) } *)  *)
(*tsolve=Select[rules,MemberQ[fluxvars,#[[1]]]&];*)
(**)
(*(*get all state variables*)*)
(*states=Join[fluxvars,{H,S}];*)
(*(*put together equations*)*)
(*eqs=(#[[1]]==(#[[2]]//.rulesnofluxvars/.((#->#[t])&/@states)))&/@Join[*)
(*(#[[1]]'[t]==(\[Lambda](Max[0,#[[2]]]-#[[1]])))&/@tsolve,*)
(*{*)
(*S'[t]==S(jSG-jST),*)
(*H'[t]==H(jHG-jHT)*)
(*}*)
(*];*)
(*(*set initial conditions*)*)
(*inis=(#[0]==(#/.inivalues))&/@states;*)
(*(*do the simulation (solve ODEs)*)*)
(*(NDSolve@@({Join[eqs/.parvals,inis],#&/@states,{t,0,tmax}}/.parvals))[[1]]];*)
(*sol=simulate[parvals,fluxvars,inivalues];*)
(*tmaxplot=tmax/.parvals;*)
(*(*plot S/H ratio*)*)
(*Plot[Evaluate[{S[t]/H[t]}/.sol],{t,0,tmaxplot},PlotLabel->"S/H",PlotRange->Full,AxesLabel->{"t"},ImageSize->Medium,AxesOrigin->{0,0}]*)
(*(*plot all state variables*)*)
(*Multicolumn[*)
(*Join[*)
(*Table[Plot[Evaluate@Flatten@{Max[0,x[t]/.sol]},{t,0,tmaxplot},PlotLabel->(x/.names),AxesLabel->{"t"},PlotRange->Full,AxesOrigin->{0,0}],{x,fluxvars}],*)
(*Table[LogPlot[x[t]/.sol,{t,0,tmaxplot},PlotLabel->(x/.{S->"S",H->"H"}),AxesLabel->{"t"},PlotRange->Full,AxesOrigin->{0,0}],{x,{S,H}}]*)
(*]*)
(*]*)


(* ::Input:: *)
(*(*simulate model with different flux combinations, plot final S/H ratio*)*)
(*(*flux state variables choices to test*)*)
(*fluxvarss={{jCP,jSG},{jCP,jHG},{jCP,\[Rho]C},{jCP,\[Rho]N}};*)
(*(*max value of ini fluxes in plot*)*)
(*maxiniflux={jCP->1,jSG->.3,jHG->.1,\[Rho]N->0.15,\[Rho]C->.5};*)
(*(*initial values for S and H*)*)
(*iniSH={S->0.3,H->1};*)
(*(*steps in horizontal and vertical direction of plot*)*)
(*steps=20;*)
(*(*function to make list of final values*)*)
(*Clear[SHlist];*)
(*SHlist[parvalues_,fluxvars_]:=SHlist[parvalues,fluxvars]=Flatten[ParallelTable[{x,y,S[tmaxplot]/H[tmaxplot]/.simulate[parvals,fluxvars,Join[iniSH,({#[[1]]->x,#[[2]]->y}&@fluxvars)]]},{x,0,fluxvars[[1]]/.maxiniflux,(fluxvars[[1]]/.maxiniflux)/steps},{y,0,fluxvars[[2]]/.maxiniflux,(fluxvars[[2]]/.maxiniflux)/steps}],1];*)
(*(*colors for plot*)*)
(*shadingcols=(ColorData[97]/@{1,2});*)


(* ::Input:: *)
(*(*function for plot*)*)
(*iniplot[parvalues_,fluxvars_]:=Column[{*)
(*Style["S/H ratio after "<> ToString[tmaxplot]<>" days",15],"",*)
(*Style[Row[{"Fluxes that are state variables: ",fluxvars/.names}],15],"",*)
(*Row[{*)
(*ListContourPlot[SHlist[parvalues,fluxvars],PlotRange->Full,FrameLabel->((#[0]&/@fluxvars)/.names),Contours->1,ContourShading->shadingcols,ImageSize->Medium],*)
(*"   ",*)
(*Column[Table[Row[{shadingcols[[i]]," ","S/H = ",{Min[#],Max[#]}[[i]]&@SHlist[parvalues,fluxvars][[All,3]]}],{i,2}]]*)
(*}],*)
(*Framed[Column[{"Parameters",Multicolumn[Join[parvalues,iniSH]/.{H->Subscript[H, 0],S->Subscript[S, 0]}/.names]},Alignment->Center]]*)
(*},Alignment->Center*)
(*];*)
(*(*make the plots with the different flux choices, export to pdf*)*)
(*(Export[NotebookDirectory[]<>"plot-final-StoH-ratio-dependence-on-initial-flux-values.pdf",#];#)&@Column[Table[iniplot[parvals,fluxvars],{fluxvars,fluxvarss}],Frame->All,Spacings->1]*)
