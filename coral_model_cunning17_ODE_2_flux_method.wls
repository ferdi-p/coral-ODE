#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title:: *)
(*Coral-algae model from Cunning et al 2017*)


(* ::Subtitle:: *)
(*Numerics: ODE method, with 2 fluxes as state variables*)


(* ::Input:: *)
(*(*parameters*)*)
(*nNH=.18;*)
(*nNS=.13;*)
(*nNX=.2;*)
(*j0HT=.03;*)
(*j0ST=.03;*)
(*\[Sigma]NH=.9;*)
(*\[Sigma]CH=.1;*)
(*\[Sigma]NS=.9;*)
(*\[Sigma]CS=.9;*)
(*jXm=.13;*)
(*KX=10^-6;*)
(*jNm=.035;*)
(*KN=1.5 10^-6;*)
(*kCO2=10;*)
(*jHGm=1;*)
(*yCL=.1;*)
(*yC=.8;*)
(*astar=1.34;*)
(*kNPQ=112;*)
(*kROS=80;*)
(*jCPm=2.8;*)
(*jSGm=0.25;*)
(*b=5;*)
(*X=1.5 10^-7;*)
(*L=30;*)
(*\[CapitalNu]=KN;(*attention this is \[CapitalNu] not N. Type: esc N esc*)*)
(*tmax=30;*)
(*(*initial values*)*)
(*inivalues={jSG->0,jCP->jCPm,H->1,S->.13};*)
(*(*convergence speed for numerical method*)*)
(*\[Lambda]=10;*)
(*(*derived*)*)
(*(*SU*)*)
(*F[\[Rho]_][A_,B_]:=(A B (A+B) \[Rho])/(A^2 B+A B^2+A^2 \[Rho]+A B \[Rho]+B^2 \[Rho]);*)
(*jX=(jXm X)/(X+KX);*)
(* jN=(jNm \[CapitalNu])/(\[CapitalNu]+KN);*)
(*jHT=j0HT;*)
(*rNS=\[Sigma]NS nNS j0ST;*)
(*jHG=F[jHGm][yC (\[Rho]C S/H+jX),(jN+nNX jX+rNH)nNH^-1];*)
(*jeC=Max[jX-jHG/yC+(S \[Rho]C)/H,0];*)
(*jCO2=jeC kCO2;*)
(*jL=A astar L;*)
(*rCH=(jHT+(jHG (1-yC))/yC) \[Sigma]CH;*)
(*jeL=jL-jCP/yCL;*)
(*jNPQ=1/(1/jeL+1/kNPQ);*)
(*jST=(1+b cROS1) j0ST;*)
(*rNH=\[Sigma]NH nNH jHT;*)
(*A=1.256307+1.385969 E^(-6.479055 S/H);*)
(*rCS=\[Sigma]CS(j0ST+(1-yC)jSG yC^-1);*)
(*cROS1=(jeL-jNPQ)/kROS;*)
(*\[Rho]C=jCP-jSG yC^-1;*)
(*\[Rho]N=Max[jN+jX nNX+rNH-jHG nNH,0];*)
(*(*SU*)*)
(*F[\[Rho]_][A_,B_]:=(A B (A+B) \[Rho])/(A^2 B+A B^2+A^2 \[Rho]+A B \[Rho]+B^2 \[Rho]);*)
(*(*list of states (fluxes) to track*)*)
(*(*format of elements in this list:*)*)
(*(*{ variable name, formula (aim for numerical implementation), initial guess (for numerical implementation) } *)  *)
(*tsolve={*)
(*{jSG,F[jSGm][jCP yC,(rNS+(H \[Rho]N)/S)/nNS]},*)
(*{jCP,F[jCPm][jL yCL,rCS+(H (jCO2+rCH))/S]/(1+cROS1)}*)
(*};*)
(*(*names of the state variables*)*)
(*names={jHG->"\!\(\*SubscriptBox[\(j\), \(HG\)]\)",\[Rho]N->"\!\(\*SubscriptBox[\(\[Rho]\), \(N\)]\)",jeC->"\!\(\*SubscriptBox[\(j\), \(eC\)]\)",jCO2->"\!\(\*SubscriptBox[\(j\), SubscriptBox[\(CO\), \(2\)]]\)",jL->"\!\(\*SubscriptBox[\(j\), \(L\)]\)",rCH->"\!\(\*SubscriptBox[\(r\), \(CH\)]\)",rCS->"\!\(\*SubscriptBox[\(r\), \(CS\)]\)",jCP->"\!\(\*SubscriptBox[\(j\), \(CP\)]\)",jeL->"\!\(\*SubscriptBox[\(j\), \(eL\)]\)",jNPQ->"\!\(\*SubscriptBox[\(j\), \(NPQ\)]\)",cROS1->"\!\(\*SubscriptBox[\(c\), \(ROS\)]\)-1",jSG->"\!\(\*SubscriptBox[\(j\), \(SG\)]\)",\[Rho]C->"\!\(\*SubscriptBox[\(\[Rho]\), \(C\)]\)",jST->"\!\(\*SubscriptBox[\(j\), \(ST\)]\)",S->"S",H->"H"};*)
(*(*get all state variables*)*)
(*states=Join[tsolve[[All,1]],{H,S}];*)
(*(*put together equations*)*)
(*eqs={#[[1]]==(#[[2]]/.((#->#[t])&/@states))}&/@Join[*)
(*(#[[1]]'[t]==(\[Lambda](Max[0,#[[2]]]-#[[1]])))&/@tsolve,*)
(*{*)
(*S'[t]==S(jSG-jST),*)
(*H'[t]==H(jHG-jHT)*)
(*}*)
(*];*)
(*(*set initial conditions*)*)
(*inis=(#[0]==(#/.inivalues))&/@states;*)
(*(*do the simulation (solve ODEs)*)*)
(*sol=NDSolve[Join[eqs,inis],#&/@states,{t,0,tmax}][[1]];*)
(*(*plot S/H ratio*)*)
(*Plot[Evaluate[{S[t]/H[t]}/.sol],{t,0,tmax},PlotLabel->"S/H",PlotRange->Full,AxesLabel->{"t"},ImageSize->Medium,AxesOrigin->{0,0}]*)
(*(*plot all state variables*)*)
(*Multicolumn[*)
(*Join[*)
(*Table[Plot[Evaluate@Flatten@{Max[0,x[[1]][t]/.sol]},{t,0,tmax},PlotLabel->(x[[1]]/.names),AxesLabel->{"t"},PlotRange->Full,AxesOrigin->{0,0}],{x,tsolve}],*)
(*Table[LogPlot[x[t]/.sol,{t,0,tmax},PlotLabel->(x/.{S->"S",H->"H"}),AxesLabel->{"t"},PlotRange->Full,AxesOrigin->{0,0}],{x,{S,H}}]*)
(*]*)
(*]*)



