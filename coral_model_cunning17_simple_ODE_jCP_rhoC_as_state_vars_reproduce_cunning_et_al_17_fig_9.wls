#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title:: *)
(*Coral-algae model from Cunning et al 2017*)


(* ::Subtitle:: *)
(*Numerics: ODE method, with 2 fluxes (jCP and \[Rho]C) as state variables*)


(* ::Input:: *)
(*(*parameters*)*)
(*nNH=.18;*)
(*nNS=.13;*)
(*nNX=0.22;*)
(*j0HT=.03;*)
(*j0ST=.03;*)
(*\[Sigma]NH=.9;*)
(*\[Sigma]CH=.1;*)
(*\[Sigma]NS=.9;*)
(*\[Sigma]CS=.9;*)
(*jXm=.13;*)
(*KX=10^-6;*)
(*jNm=.035;*)
(*KN=1.5 10^-6;*)
(*kCO2=10;*)
(*jHGm=1;*)
(*yCL=.1;*)
(*yC=.8;*)
(*astar=1.34;*)
(*kNPQ=112;*)
(*kROS=80;*)
(*jCPm=2.8;*)
(*jSGm=0.25;*)
(*b=5;*)
(*X=10^-7;*)
(*L=20;*)
(*\[CapitalNu]=10^-7;(*attention this is \[CapitalNu] not N. Type: esc N esc*)*)
(*tmax=250;*)
(*(*initial values*)*)
(*inivalues={\[Rho]C->1,jCP->1,H->1000,S->1};*)
(*(*convergence speed for numerical method*)*)
(*\[Lambda]=10;*)
(*(*derived*)*)
(*(*SU*)*)
(*F[\[Rho]_][A_,B_]:=(A B (A+B) \[Rho])/(A^2 B+A B^2+A^2 \[Rho]+A B \[Rho]+B^2 \[Rho]);*)
(*jX=(jXm X)/(X+KX);*)
(*jN=(jNm \[CapitalNu])/(\[CapitalNu]+KN);*)
(*jHT=j0HT;*)
(*rNS=\[Sigma]NS nNS j0ST;*)
(*jHG=F[jHGm][yC (\[Rho]C S/H+jX),(jN+nNX jX+rNH)nNH^-1];*)
(*jeC=jX+\[Rho]C S/H-jHG/yC;*)
(*jCO2=jeC kCO2;*)
(*jL=A astar L;*)
(*rCH=(jHT+(jHG (1-yC))/yC) \[Sigma]CH;*)
(*jeL=jL-jCP/yCL;*)
(*jNPQ=1/(1/jeL+1/kNPQ);*)
(*jST=(1+b cROS1) j0ST;*)
(*rNH=\[Sigma]NH nNH jHT;*)
(*A=1.256307+1.385969 E^(-6.479055 S/H);*)
(*rCS=\[Sigma]CS(j0ST+(1-yC)jSG yC^-1);*)
(*cROS1=(jeL-jNPQ)/kROS;*)
(*jSG=F[jSGm][jCP yC,(rNS+(H \[Rho]N)/S)/nNS];*)
(*\[Rho]N=jN+jX nNX+rNH-jHG nNH;*)
(*(*list of states (fluxes) to track*)*)
(*(*format of elements in this list:*)*)
(*(*{ variable name, formula (aim for numerical implementation), initial guess (for numerical implementation) } *)  *)
(*tsolve={*)
(*{jCP,F[jCPm][jL yCL,rCS+(H (jCO2+rCH))/S]/(1+cROS1)},*)
(*{\[Rho]C,jCP-jSG yC^-1}*)
(*};*)
(*(*names of the state variables*)*)
(*names={jHG->"\!\(\*SubscriptBox[\(j\), \(HG\)]\)",\[Rho]N->"\!\(\*SubscriptBox[\(\[Rho]\), \(N\)]\)",jeC->"\!\(\*SubscriptBox[\(j\), \(eC\)]\)",jCO2->"\!\(\*SubscriptBox[\(j\), SubscriptBox[\(CO\), \(2\)]]\)",jL->"\!\(\*SubscriptBox[\(j\), \(L\)]\)",rCH->"\!\(\*SubscriptBox[\(r\), \(CH\)]\)",rCS->"\!\(\*SubscriptBox[\(r\), \(CS\)]\)",jCP->"\!\(\*SubscriptBox[\(j\), \(CP\)]\)",jeL->"\!\(\*SubscriptBox[\(j\), \(eL\)]\)",jNPQ->"\!\(\*SubscriptBox[\(j\), \(NPQ\)]\)",cROS1->"\!\(\*SubscriptBox[\(c\), \(ROS\)]\)-1",jSG->"\!\(\*SubscriptBox[\(j\), \(SG\)]\)",\[Rho]C->"\!\(\*SubscriptBox[\(\[Rho]\), \(C\)]\)",jST->"\!\(\*SubscriptBox[\(j\), \(ST\)]\)",S->"S",H->"H",A->"A",Log[Min[jCPm,rCS+(H (jCO2+rCH))/S]/Min[jCPm,jL yCL]]->"Log[\!\(\*FractionBox[\(Min[\*SubscriptBox[\(j\), \(CPm\)], \*SubscriptBox[\(r\), \(CS\)] + \((\*SubscriptBox[\(j\), \(CO2\)] + \*SubscriptBox[\(r\), \(CH\)])\) \*FractionBox[\(H\), \(S\)]]\), \(Min[\*SubscriptBox[\(j\), \(CPm\)], \*SubscriptBox[\(j\), \(L\)]\\\ \*SubscriptBox[\(y\), \(CL\)]]\)]\)]",Log[Min[jSGm,jCP yC]/Min[jSGm,(rNS+(H \[Rho]N)/S)/nNS]]->"Log[\!\(\*FractionBox[\(Min[\*SubscriptBox[\(j\), \(SGm\)], \*SubscriptBox[\(j\), \(CP\)]\\\ \*SubscriptBox[\(y\), \(C\)]]\), \(Min[\*SubscriptBox[\(j\), \(SGm\)], \((\*SubscriptBox[\(r\), \(NS\)] + \*SubscriptBox[\(\[Rho]\), \(N\)] \*FractionBox[\(H\), \(S\)])\) \*SuperscriptBox[SubscriptBox[\(n\), \(NS\)], \(-1\)]]\)]\)]",Log[Min[jHGm,yC (\[Rho]C S/H+jX)]/Min[jHGm,(jN+nNX jX+rNH)nNH^-1]]->"Log[\!\(\*FractionBox[\(Min[\*SubscriptBox[\(j\), \(HGm\)], \*SubscriptBox[\(y\), \(C\)]\\\ \((\*SubscriptBox[\(\[Rho]\), \(C\)]\\\ \*FractionBox[\(S\), \(H\)] + \*SubscriptBox[\(j\), \(X\)])\)]\), \(Min[\*SubscriptBox[\(j\), \(HGm\)], \((\*SubscriptBox[\(j\), \(N\)] + \*SubscriptBox[\(n\), \(NX\)]\\\ \*SubscriptBox[\(j\), \(X\)] + \*SubscriptBox[\(r\), \(NH\)])\) \*SuperscriptBox[SubscriptBox[\(n\), \(NH\)], \(-1\)]]\)]\)]",S/H->"\!\(\*FractionBox[\(S\), \(H\)]\)",Log[S]->"Log[S]",Log[H]->"Log[H]"};*)
(*(*get all state variables*)*)
(*states=Join[tsolve[[All,1]],{H,S}];*)
(*(*put together equations*)*)
(*addtimetostates=((#->#[t])&/@states);*)
(*eqs={#[[1]]==(#[[2]]/.addtimetostates)}&/@Join[*)
(*(#[[1]]'[t]==(\[Lambda](Max[0,#[[2]]]-#[[1]])))&/@tsolve,*)
(*{*)
(*S'[t]==S(jSG-jST),*)
(*H'[t]==H(jHG-jHT)*)
(*}*)
(*];*)
(*(*set initial conditions*)*)
(*inis=(#[0]==(#/.inivalues))&/@states;*)
(*(*do the simulation (solve ODEs)*)*)
(*sol=NDSolve[Join[eqs,inis],#&/@states,{t,0,tmax}][[1]];*)
(**)
(*(*plots*)*)
(*toplot={S/H,Log[S],Log[H],jHG,jeC,jCO2,jL,rCH,jeL,jNPQ,jST,A,rCS,cROS1,\[Rho]C,\[Rho]N,jSG,jCP,Log[Min[jCPm,rCS+(H (jCO2+rCH))/S]/Min[jCPm,jL yCL]],Log[Min[jSGm,jCP yC]/Min[jSGm,(rNS+(H \[Rho]N)/S)/nNS]],Log[Min[jHGm,yC (\[Rho]C S/H+jX)]/Min[jHGm,(jN+nNX jX+rNH)nNH^-1]]};*)
(*(Export["Simulations_Fig9_nNX="<>StringReplace[ToString[nNX],"."->"dot"]<>".pdf",#];#)&@Column[{Row[{"\!\(\*SubscriptBox[\(n\), \(NX\)]\)=",nNX}],Multicolumn[*)
(*Join[*)
(*Table[Plot[Evaluate@Flatten@{x/.addtimetostates/.sol},{t,0,tmax},PlotLabel->(x/.names),AxesLabel->{"t"},PlotRange->Full,AxesOrigin->{0,0}],{x,toplot}]*)
(*]*)
(*]}]*)
